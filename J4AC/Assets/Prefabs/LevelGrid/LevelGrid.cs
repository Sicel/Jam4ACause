using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LevelGrid : MonoBehaviour
{
    public static LevelGrid CurrLevelGrid { get; private set; }

    [Tooltip("The matrix dimensions of the grid")]
    public Vector2Int gridDimensions;

    [Tooltip("The length of a single grid unit, i.e. 1.0f = 1 grid unit. Use this with relative positioning.")]
    public float SizePerUnit = 1.0f;

    [Tooltip("List of grid objects not generated by this, ie player, goal, door.")]
    public List<GameObject> gridElements;

    [Header("Auto Generate a background grid")]
    public bool GenerateGrid = false;

    [Tooltip("An object to represent a grid tile.")]
    public GameObject gridTile;

    [Tooltip("List of grids generated")]
    public List<GameObject> gridBase;

    // Helper instances of the player
    private GameObject PlayerElement;
    private PlayerTile playerTile;

    // Helper instances of the goal
    private GameObject GoalElement;
    private Tile goalTile;


    /// <summary>
    /// 
    /// </summary>
    private void Awake()
    {
        CurrLevelGrid = this;
    }


    /// <summary>
    /// Start is called before the first frame update
    /// </summary>
    void Start()
    {

    }


    /// <summary>
    /// 
    /// </summary>
    void Update()
    {

    }


    /// <summary>
    /// 
    /// </summary>
    void OnValidate()
    {
        CurrLevelGrid = this;
        if (GenerateGrid)
        {
            // Make a new list if null
            if (gridBase == null)
                gridBase = new List<GameObject>(gridDimensions.x * gridDimensions.y);

            // Fill list if base tile isn't null
            if (gridTile != null)
            {
                int gridsUnitsGenerated = 0;

                for (int i = 0; i < gridDimensions.x; i++)
                {
                    for (int j = 0; j < gridDimensions.y; j++)
                    {
                        Tile tile;
                        if (gridsUnitsGenerated < gridBase.Count && gridBase[gridsUnitsGenerated] != null)
                        {
                            // Repurpose existing grid unit.
                            gridBase[gridsUnitsGenerated].SetActive(true);
                            tile = gridBase[gridsUnitsGenerated].GetComponent<Tile>();
                        }
                        else
                        {
                            // Generate a grid element and position it
                            GameObject newGridTile = Instantiate(gridTile, this.transform);
                            gridBase.Add(newGridTile);
                            tile = newGridTile.GetComponent<Tile>();
                        }

                        // Position that tile
                        tile.SizePerUnit = this.SizePerUnit;
                        tile.SnapToTile(new Vector2Int(i, j));

                        gridsUnitsGenerated += 1;
                    }
                }

                // If we're decreasing the number of grid units, set any pre-existing to false.
                for (int i = gridsUnitsGenerated; i < gridBase.Count; i++)
                {
                    if (gridBase[i] != null)
                        gridBase[i].SetActive(false);
                }
            }

            GenerateGrid = false;
        }
    }


    #region PUBLIC FUNCTIONS


    public void ResetLevel()
    {
        // Reset the background tiles
        foreach (GameObject tile in gridBase)
        {
            tile.GetComponent<Tile>().ResetTile();
        }

        // Reset the foreground tiles
        foreach (GameObject tile in gridElements)
        {
            tile.GetComponent<Tile>().ResetTile();
        }
    }


    /// <summary>
    /// Adds a tile to be keep tracked of and monitored.
    /// </summary>
    public void AddTile(GameObject tile)
    {
        // Safety check
        if (gridElements == null)
            gridElements = new List<GameObject>();

        // Add this tile if unique
        if (!gridElements.Contains(tile))
        {
            gridElements.Add(tile);
        }

        // Set this as the parent so its grid positioning is relative
        tile.transform.parent = this.transform;
        tile.GetComponent<Tile>().SnapToTile();
    }


    public void AddPlayerTile(GameObject tile)
    {
        AddTile(tile);

        PlayerElement = tile;
        playerTile = PlayerElement.GetComponent<PlayerTile>();
    }





    /// <summary>
    /// Checks if another tile element can go through a tile unit.
    /// </summary>
    /// <param name="gridCoordinate"></param>
    /// <returns></returns>
    public bool CanGoThroughTile(Vector2Int gridCoordinate)
    {
        // For ease of reading/coding
        int x = gridCoordinate.x;
        int y = gridCoordinate.y;

        // If we're out of bounds of this grid, return false.
        if (x < 0 || x >= gridDimensions.x || y < 0 || y > gridDimensions.y)
        {
            return false;
        }

        // Otherwise, check if there's anything there that would be impedeing otherwise. 
        bool canGoThrough = true;
        foreach (GameObject tileElement in gridElements)
        {
            // Check each tile if they're in this specific spot and if the asking tile can go through it.
            //      This is an O(n) operation performing on gridElements.
            //      Ideally, I would change this to an O(1) operation since a grid should store everything
            //          on a matrix. For now though, gridElements should be relatively small (ie, just 
            //          player, door, and goal). 
            Tile tile = tileElement.GetComponent<Tile>();

            if (tile.location.x == x && tile.location.y == y)
            {
                // If any tile cannot be go-ed through, fail.
                canGoThrough = canGoThrough && tile.CanGoThrough();
            }
        }

        return canGoThrough;
    }

    public bool CanGoThroughTile(int x, int y)
    {
        return CanGoThroughTile(new Vector2Int(x, y));
    }

    #endregion
}
